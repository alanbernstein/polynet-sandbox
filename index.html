<!DOCTYPE html>
<html>

<head>
    <script src="https://unpkg.com/konva@8.3.5/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>polynet sandbox</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script>
        /*
        TODO:
        - add edge labels manually
        - snap: 
          - https://konvajs.org/docs/sandbox/Objects_Snapping.html
          - just snap to triangle grid
            - https://kvachev.com/blog/posts/triangular-grid/
            - https://medium.com/@pierrebleroux/snap-to-grid-with-konvajs-c41eae97c13f
            - https://web.archive.org/web/20210619034631/https://davehardee.com/QRSCoords/
        - rotate entire grid 30 degrees
        - cycle between possible neighbors with key
        - generate edges labels automatically
        - buttons to show example layouts
        - interface hints
        - replace edge labels with some color
        - checkboxes to toggle grid dots, lines, face labels, etc
        x display all shapes
        x define positions on triangular grid
        x rotate with key: https://konvajs.org/docs/events/Keyboard_Events.html#sidebar
        x put text on each edge
        x rotate shape with labels: https://konvajs.org/docs/drag_and_drop/Drag_a_Group.html
        x drag and drop https://konvajs.org/docs/drag_and_drop/Drag_and_Drop.html
        */

        S = 65; // triangle side length
        r3 = Math.sqrt(3)


        function createTriangle(Cxy, phase, edgeLabels, faceLabel) {

            var poly = new Konva.Group({
                rotation: 0,
                draggable: true,
                x: Cxy[0],
                y: Cxy[1],
            });

            var shape = new Konva.Line({
                points: [
                    S * Math.cos(phase + Math.PI * 1 / 3), S * Math.sin(phase + Math.PI * 1 / 3),
                    S * Math.cos(phase + Math.PI * 3 / 3), S * Math.sin(phase + Math.PI * 3 / 3),
                    S * Math.cos(phase + Math.PI * 5 / 3), S * Math.sin(phase + Math.PI * 5 / 3),
                ],
                fill: '#fff',
                stroke: 'black',
                strokeWidth: 2,
                closed: true,
            });

            poly.add(shape)

            edgeLabelConfig = {
                fontFamily: 'Calibri',
                fontSize: 10,
                fill: 'black',
                align: 'center',
                strokeWidth: 1,
                rotation: 0,
                listening: false,
            }
            faceLabelConfig = {
                fill: 'green',
            }

            textPhases = [Math.PI * 0 / 3, Math.PI * 2 / 3, Math.PI * 4 / 3];
            for (n = 0; n < 3; n++) {
                textDetails = {
                    text: edgeLabels[n],
                    x: (S/r3 * 0.4) * Math.cos(Math.PI * 0 / 3 + phase + textPhases[n]),
                    y: (S/r3 * 0.4) * Math.sin(Math.PI * 0 / 3 + phase + textPhases[n]),
                }
                var text = new Konva.Text({
                    ...textDetails,
                    ...edgeLabelConfig
                });
                poly.add(text);
            }

            textDetails = {
                text: faceLabel,
                x: 0,
                y: 0,
            }
            var text = new Konva.Text({
                ...textDetails,
                ...edgeLabelConfig,
                ...faceLabelConfig
            });
            poly.add(text);

            poly.on('mouseover', function () {
                active = this;
                document.body.style.cursor = 'pointer';
            });
            poly.on('mouseout', function () {
                document.body.style.cursor = 'default';
            });
            poly.on('dragend', (e) => {
                // snap to triangle grid

                // square grid
                //poly.position({
                //    x: Math.round(rectangle.x() / blockSize) * blockSize,
                //    y: Math.round(rectangle.y() / blockSize) * blockSize
                //});
                stage.batchDraw();
            });

            return poly
        }

        function cartesianFromTriGrid(tri) {
            // https://www.boristhebrave.com/2021/05/23/triangle-grids/#How_to_Use_Triangles_Grids
            a=tri[0]; b=tri[1]; c=tri[2];
            x = (  0.5 * a +            -0.5 * c) * S*2;
            y = (-r3/6 * a + r3/3 * b - r3/6 * c) * S*2;
            return [x, y]
        }

        function cartesianFromHexGrid(hex, par=0) {
            r = hex[1]; c = hex[0];
            x = 1.5*c - .5*par;
            y = r3*r + r3/2*(c%2) + r3/2 * par;
            return [x*S, y*S];
        }
        

        var width = window.innerWidth;
        var height = window.innerHeight;

        var stage = new Konva.Stage({
            container: 'container',
            width: width,
            height: height,
        });

        var layer = new Konva.Layer();
        W = stage.width();
        H = stage.height();

        C = 3; R = 0;
        net1 = [
            // hex grid vertex index, parity bit which controls rotation and translation, edge labels, face label
            [[C, R+1], 0, [0, 1, 2], 0],
            [[C, R+1], 1, [-1, -1, -1], 1],
            [[C, R+2], 0, [-2, -2, -2], 2],
            [[C, R+2], 1, [-3, -3, -3], 3],
            [[C, R+3], 0, [-2, -2, -2], 4],
            [[C, R+3], 1, [-3, -3, -3], 5],
            [[C, R+4], 0, [-2, -2, -2], 6],
            [[C, R+4], 1, [-3, -3, -3], 7],
            [[C, R+5], 0, [-2, -2, -2], 8],
            [[C, R+5], 1, [-3, -3, -3], 9],

            [[C+1, R+1], 1, [-5, -5, -5], 10],
            [[C+1, R+1], 0, [-4, -4, -4], 11],
            [[C+2, R+0], 1, [-5, -5, -5], 12],
            [[C+2, R+1], 0, [-5, -5, -5], 13],
            [[C+2, R+1], 1, [-5, -5, -5], 14],

            [[C-1, R+6], 0, [-3, -3, -3], 15],
            [[C-1, R+6], 1, [-3, -3, -3], 16],
            [[C-2, R+6], 0, [-3, -3, -3], 17],
            [[C-2, R+5], 1, [-3, -3, -3], 18],
            [[C-2, R+5], 0, [-3, -3, -3], 19],

        ]

        for (var k = 0; k < net1.length; k++) {
            //xy = cartesianFromTriGrid(data[k][0]);
            rc = net1[k][0]; par = net1[k][1]; edgeLabels = net1[k][2]; faceLabel = net1[k][3];
            xy = cartesianFromHexGrid(rc, par);
            console.log(k, rc, xy)
            poly = createTriangle(xy, Math.PI * par / 3, edgeLabels, faceLabel);
            layer.add(poly);
        }
        active = poly;

        // draw grid - vertices
        M = 8;
        for(a=0; a<M; a++) {
            for(b=0; b<M; b++) {
                xy = cartesianFromHexGrid([a, b]);
                var circle = new Konva.Circle({x: xy[0], y: xy[1], radius: 2, fill: 'red'});
                layer.add(circle);
                //xy = cartesianFromHexGrid([a, b], 1);
                //var circle = new Konva.Circle({x: xy[0], y: xy[1], radius: 2, fill: 'green'});
                //layer.add(circle);
                xy = cartesianFromHexGrid([a, b], -1);
                var circle = new Konva.Circle({x: xy[0], y: xy[1], radius: 2, fill: 'blue'});
                layer.add(circle);
            }
        }

        stage.add(layer);

        var container = stage.container();
        container.tabIndex = 1;        // make it focusable
        container.focus();        // focus it. also stage will be in focus on its click

        const translateDelta = 4;
        const rotateDeltaDeg = 60;
        container.addEventListener('keydown', function (e) {
            if (e.keyCode === 69) {
                active.rotate(rotateDeltaDeg);
            } else if (e.keyCode === 81) {
                active.rotate(-rotateDeltaDeg);
            } else if (e.keyCode === -1) {
                // TODO move to next edge
            } else if (e.keyCode === -1) {
                // TODO move to previous edge
            } else if (e.keyCode === 37) {
                active.x(active.x() - translateDelta);
            } else if (e.keyCode === 38) {
                active.y(active.y() - translateDelta);
            } else if (e.keyCode === 39) {
                active.x(active.x() + translateDelta);
            } else if (e.keyCode === 40) {
                active.y(active.y() + translateDelta);
            } else {
                return;
            }
            e.preventDefault();
        });

    </script>
</body>